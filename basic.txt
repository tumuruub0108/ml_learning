# 1. What is a Training Set?
The training set is the portion of your dataset that the model learns from. It contains input features (X) and the corresponding labels/targets (y). The model adjusts its parameters/weights based on this data.

# How to Create a Training Set
    Collect your dataset
        Example: Housing dataset with 50,000 rows and columns like size, location, year, and price
    Split the dataset
        Common ratios:
            70% train, 15% validation, 15% test
            Or 80% train, 10% validation, 10% test
            Example: If you have 50,000 rows → 35,000 rows go to training.

    👉 In Python, you usually use train_test_split from sklearn:
    from sklearn.model_selection import train_test_split
    # X = features, y = target
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42)  # 70% train, 30% temp
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42)  # 15% val, 15% test
        

# Preprocess the training data
    Handle missing values (drop, fill, impute).
    Normalize or standardize numeric features.(scaling)
    Encode categorical features (one-hot, label encoding).

# Feed it into your model
    Example with scikit-learn:
        from sklearn.linear_model import LinearRegression
        model = LinearRegression()
        model.fit(X_train, y_train)   # train on the training set

✅ Summary:
The training set is made by splitting the original dataset (usually ~70–80%) and then cleaning + preprocessing it before feeding it into the mode


# 2. What Does "Testing a Model" Mean?
After you train your model on the training set (and fine-tune it using the validation set), you need to check how well it performs on completely new, unseen data.

# That’s where the test set comes in.
    The test set is a separate portion of your dataset that the model has never seen before.
    Testing the model = evaluating its final performance (accuracy, RMSE, F1-score, etc.) on this unseen test set.

# Why Do We Test a Model?
    To estimate generalization performance (how well the model works on real-world data).
    To ensure we’re not just memorizing the training data (overfitting).
    To get a fair, unbiased evaluation before deploying the model.


     Simple example:
        from sklearn.linear_model import LinearRegression
        from sklearn.metrics import mean_squared_error
   
        # Train model
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Validate (during training)
        val_predictions = model.predict(X_val)
        val_rmse = mean_squared_error(y_val, val_predictions, squared=False)
        print("Validation RMSE:", val_rmse)

        # Test (final check)
        test_predictions = model.predict(X_test)
        test_rmse = mean_squared_error(y_test, test_predictions, squared=False)
        print("Test RMSE:", test_rmse)


        Here:
            X_train, y_train → used to train.
            X_val, y_val → used to tune hyperparameters.
            X_test, y_test → used only once at the end to test the model.

✅ In short:
    Training a model = teaching it patterns.
    Testing a model = checking how well it learned, using unseen data.



# 3. What is Model Validation?
Validating a model means checking how well your model performs on data it hasn’t seen during training, but still using it to tune or select the best model.

    The validation set is separate from the training set.

    You don’t train on this data.

    You use it to guide improvements—like hyperparameter tuning, choosing the best algorithm, or deciding when to stop training.

# Why Validate a Model?
    Prevent Overfitting
        A model might do great on training data but poorly on unseen data.
        Validation helps check if it’s generalizing well.

    Tune Hyperparameters
        Learning rate, number of layers, regularization strength, etc.
        Validation set is used to find the best combination.

    Model Selection
        If you try multiple models (Linear Regression, Random Forest, XGBoost), the validation set helps you choose the one that works best.

    Simple example:
        from sklearn.linear_model import LinearRegression
        from sklearn.metrics import mean_squared_error

        # Train model
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Validate model
        val_predictions = model.predict(X_val)
        val_rmse = mean_squared_error(y_val, val_predictions, squared=False)
        print("Validation RMSE:", val_rmse)

    X_train, y_train → model learns patterns
    X_val, y_val → model is checked and tuned, but not trained on

    # Simple Analogy:
        Training set = learning to solve problems at home
        Validation set = taking practice tests to see how well you learned
        Test set = taking the final exam to see your true performance

# What is Fine-Tuning?
Fine-tuning is the process of adjusting a model’s settings or parameters to improve its performance on your specific task or dataset.

# Think of it like this:
    You train a model → it learns general patterns.
    You fine-tune the model → you tweak it so it works better for your specific data or problem

# Two Common Contexts for Fine-Tuning
    Hyperparameter Fine-Tuning:
        Hyperparameters are settings not learned by the model (e.g., learning rate, number of layers, number of trees in random forest).
        Fine-tuning = trying different hyperparameter values to get the best validation performance.

    Model Fine-Tuning in Transfer Learning
        You take a pre-trained model (like GPT, ResNet) and adjust it for your specific dataset or task.
        Example: A model trained on ImageNet (general images) → fine-tuned on medical X-ray images.

# Why Fine-Tune?
    To improve accuracy or reduce errors.
    To adapt a general model to your specific problem.
    To avoid overfitting or underfitting by selecting optimal settings.

# Simple Analogy:
    Training a model = learning math in school.
    Fine-tuning = practicing specific types of problems before an exam to get better at them.




# Practical Tips
    Shuffle data before splitting to ensure randomness.
    For time series, use chronological split (don’t shuffle).
    Normalize/standardize after splitting to avoid data leakage.
    Monitor both training and validation loss to detect overfitting.

# Why We Shuffle Data

When you split your dataset into train, validation, and test sets, the order of the data matters. Many datasets are collected in a structured or time-ordered way, which can bias your model if you don’t shuffle.

1. Avoid Bias in Splits
    Example: Suppose you have a dataset of houses sorted by year built (oldest → newest).
    If you take the first 70% as training, the model only sees older houses during training.
    When tested on newer houses (validation/test), the model might perform poorly because it hasn’t learned patterns from recent data.
    Shuffling solves this by randomizing rows so that training/validation/test sets represent the full distribution of data.

2. Improve Generalization
    Randomly shuffling ensures the model sees a diverse mix of data in each batch.
    This helps prevent the model from learning order-specific patterns that don’t generalize.

3. Important in Mini-Batch Training
    Neural networks often train in mini-batches.
    If batches are not shuffled, batches may contain similar or correlated samples, slowing down learning or causing poor convergence.

4. Exceptions
    Time-series data:
        Do not shuffle, because chronological order matters.
        Use time-based split: train on past, validate/test on future.
    Streaming data / sequential models:
        Order may carry meaning (e.g., text, sensor readings).

# Example in Python
    from sklearn.model_selection import train_test_split

    # X = features, y = target
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42, shuffle=True
    )


# Summary:
    Shuffling ensures randomness, diversity, and unbiased splits.
    Prevents the model from learning patterns based on the order of the dataset.
    Essential for generalization, except for time-dependent or sequential data.




# Testing model
When testing models, regression and classification tasks use different metrics because the outputs are different (continuous vs categorical). But some concepts overlap, and there are a few metrics or evaluation ideas that can be used in both contexts. Let me explain clearly.

1. Regression Metrics (for continuous outputs)
| Metric                                    | What it measures                                             | Notes                              |
| ----------------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| **MSE (Mean Squared Error)**              | Average squared difference between predicted and true values | Sensitive to outliers              |
| **RMSE (Root Mean Squared Error)**        | Square root of MSE                                           | Same unit as target                |
| **MAE (Mean Absolute Error)**             | Average absolute difference                                  | Less sensitive to outliers         |
| **R² (Coefficient of Determination)**     | How much variance is explained by the model                  | 1 = perfect fit, 0 = predicts mean |
| **MAPE (Mean Absolute Percentage Error)** | Relative error (%)                                           | Only for non-zero targets          |


2. Classification Metrics (for discrete outputs)
| Metric                   | What it measures                     | Notes                                  |
| ------------------------ | ------------------------------------ | -------------------------------------- |
| **Accuracy**             | Fraction of correct predictions      | Good for balanced classes              |
| **Precision**            | True positives / predicted positives | Important for false positive control   |
| **Recall (Sensitivity)** | True positives / actual positives    | Important for false negatives          |
| **F1-score**             | Harmonic mean of precision & recall  | Balances precision and recall          |
| **ROC-AUC**              | Area under ROC curve                 | Measures ranking ability of classifier |

3. Metrics or Concepts That Can Be Used in Both
    Some evaluation ideas are shared or adapted:
        Loss Function
            Regression: MSE, MAE used during training → lower is better
            Classification: Cross-entropy loss → lower is better
            Concept: “Loss” = how far off predictions are

        R² or Explained Variance for Classification
            Rare, but for probabilistic predictions, you can measure how well predicted probabilities fit true labels.

        Prediction vs Ground Truth Comparison
            Regression: compare continuous predictions to actual values
            Classification: compare predicted class vs actual class

        Correlation / Rank-Based Metrics
            For regression: Pearson or Spearman correlation between predicted and true values
            For classification: can compute correlation on predicted probabilities (e.g., for ranking tasks)


# What Are Outliers?
Outliers are data points that are significantly different from most of the other data.

They can be unusually high, low, or just inconsistent with the general pattern.

Example (Numerical Data):
    Dataset: [10, 12, 11, 13, 12, 100]
    Here, 100 is an outlier, because it’s much larger than the other numbers.

Example (Real-world):
    House prices in a city: Most houses cost $200k–$500k, but one mansion costs $10 million → outlier.


# Why Outliers Occur
    Data entry errors
        Typo in measurement: height = 250 cm instead of 150 cm.
    Measurement errors
        Faulty sensor readings.
    Natural variability
        Extreme but valid cases: extremely tall people, very expensive houses.
    Fraud or rare events
        Unusual transactions in finance or healthcare.

# Why Outliers Matter in Machine Learning
    Can skew the model: Especially in regression or distance-based algorithms (like linear regression or k-NN).
    Can increase error metrics like MSE, RMSE.
    May affect normalization/standardization (mean, std).
    Sometimes outliers contain important information → must carefully decide to remove or keep.

# How to Detect Outliers
    Visualization
        Boxplot: points outside the whiskers
        Scatter plot: points far from cluster

    Statistical methods
        Z-score: z = (x - mean) / std, usually |z| > 3 is an outlier
        IQR (Interquartile Range): Q1 - 1.5*IQR and Q3 + 1.5*IQR

    Model-based detection
        Isolation Forest, DBSCAN, or clustering methods

# How to Handle Outliers
    Remove them → if clearly erroneous.
    Transform data → log or square root to reduce effect.
    Use robust models → models less sensitive to outliers (like Random Forest, robust regression).
    Cap or Winsorize → limit extreme values to a threshold.

# What is correlation 
Correlation is a statistical measure that shows how strongly two variables are related to each other.
If two things change together in a predictable way, they are said to be correlated.

The most common measure is the correlation coefficient (often denoted as r), which ranges from -1 to +1:
    +1 → perfect positive correlation (when one increases, the other always increases).
    0 → no correlation (no relationship between them).
    -1 → perfect negative correlation (when one increases, the other always decreases)

Example:
    Positive correlation: The number of hours studied and exam score → usually, more study hours means higher scores.
    Negative correlation: The speed of a car and the time it takes to reach a destination → higher speed means less time.
    No correlation: Shoe size and intelligence → unrelated.


# Capped data
means extreme values (outliers) have been limited to a certain threshold.(Хэтэрхий хэтэрхий их/бага утгуудыг (outliers) тодорхой босгонд хязгаарласан.)

    Example: If most incomes are below $200k but some are $5M, you might cap all values above $200k at $200k.
    Жишээ: Хэрэв ихэнх орлого 200,000$-оос доош байхад зарим нь 5,000,000$ бол 200,000$-оос дээш утгыг бүгдийг нь 200,000 гэж авдаг.
    Purpose: Reduce the negative impact of outliers on model training.
    Зорилго: Outlier-ууд загварыг буруу сургахаас сэргийлэх.

# clustering
Clustering is the process of grouping similar data points together based on their features, without using labeled data.
When data is clustered, it means the algorithm has divided the dataset into groups (called clusters) such that:

    Points in the same cluster are more similar to each other.
    Points in different clusters are more different from each other.

Example:
    Suppose you have data about customers:
        Age
        Income
        Spending habits

    A clustering algorithm might group them into:
        Cluster 1: Young, low income, low spending
        Cluster 2: Middle-aged, medium income, medium spending
        Cluster 3: Older, high income, high spending
        
No labels are provided—the algorithm “discovers” these groups automatically.

# Stratified
In machine learning, “stratified” usually refers to stratified sampling or stratified splitting, which is a way of dividing data into train/test (or folds in cross-validation) while preserving the distribution of labels or classes.

📊 Example:
Suppose you have a dataset with 100 samples:
    80 are class A
    20 are class B

If you do a random split into 80% training and 20% testing, you might end up with:
    Train: 70 A, 10 B
    Test: 10 A, 10 B (imbalanced compared to original)

But with a stratified split, the ratio is preserved:
    Train: 64 A, 16 B (still 80:20 ratio)
    Test: 16 A, 4 B (still 80:20 ratio)

Why it’s important:
    Prevents bias in model evaluation.
    Especially useful for imbalanced datasets (where some classes are rare).
    Helps the model generalize better and ensures fair testing.

# Skewed Data
Skewed data means the distribution of a feature is not symmetric around the mean.
In other words, the data is “pulled” more to one side, instead of forming a nice bell curve (normal distribution).

    Normal distribution → symmetric (mean ≈ median ≈ mode).
    Skewed distribution → asymmetric (mean, median, mode differ).

🔹 Types of Skewness
        Right Skew (Positive Skew)
            Long tail on the right (high values).
            Mean > Median.
            Example: income, house prices (a few very rich people pull the average up).

        Left Skew (Negative Skew)
            Long tail on the left (low values).
            Mean < Median.
            Example: student exam scores (if most do well but a few score very low).

🔹 Why Skewness Matters in Machine Learning
        Algorithms assume normality
            Linear regression, logistic regression, and many statistical tests assume data is roughly normally distributed.
            Skewed data can bias coefficients and predictions.

        Influence of outliers
            Skewness often means outliers are present (very high or very low values).
            Models may overfit to these.
        Model performance
            Some models (e.g., tree-based like Random Forests, XGBoost) are less sensitive.
            But distance-based models (k-NN, clustering) can be heavily affected.
🔹 Example
    If income = [20k, 30k, 50k, 60k, 200k, 500k, 1M],
        Raw → very skewed (few very high earners).
        Log-transformed → distribution looks more “normal.”

# What is Bucketizing in Machine Learning?
Bucketizing (also called binning or discretization) means converting a continuous numerical variable into discrete bins (intervals).

Instead of keeping raw continuous values, you group them into “buckets.”

Example:
Suppose you have ages: [15, 18, 22, 30, 45, 60, 75]
After bucketizing into bins:
    0–18 → Teen
    19–35 → Young Adult
    36–55 → Adult
    56+ → Senior
Result: [Teen, Teen, Young Adult, Young Adult, Adult, Senior, Senior]

✅ Benefits:
        Simplifies continuous variables → makes models easier to interpret.
        Captures non-linear effects → sometimes relationships are not linear (e.g., income vs. happiness).
        Handles outliers better → extreme values fall into the same bucket instead of distorting the scale.
        Useful for categorical models → some algorithms (like decision trees) work well with binned data.
        Feature engineering → creates new features, e.g., grouping income levels

🔹 Types of Bucketizing
        Equal-width binning
            Divide the range into intervals of equal size.
            Example: 0–20, 20–40, 40–60.
        Equal-frequency binning (quantile binning)
            Each bin has (approximately) the same number of samples.
            Example: quartiles (Q1, Q2, Q3, Q4).
        Custom binning
            Based on domain knowledge (e.g., age groups like child/teen/adult/senior).


# what is heavy tail 
In Machine Learning (ML) and statistics, a heavy tail refers to a probability distribution where the probability of very large values (extreme outcomes) decreases more slowly than it would in a "normal" distribution like the Gaussian.э?

Heavy tail гэдэг нь өгөгдлийн магадлалын тархалт нь маш их утгууд (экстрем утгууд) гарах магадлал их байдаг гэсэн үг юм.

Өөрөөр хэлбэл:
Ердийн (Normal) тархалт → дундажийн орчимд утгууд их төвлөрч, маш том эсвэл маш жижиг утгууд ховор тохиолдоно.
Heavy-tailed тархалт (жишээ нь: Pareto, Cauchy, Student’s t) → маш том утгууд, онцгой (outlier) утгууд илүү олон гардаг.

Жишээ:
    Хүн амын орлого: ихэнх нь дундаж орчимд, гэхдээ маш цөөн хэд нь маш өндөр орлоготой байдаг.
    Интернэтийн сүлжээний ачаалал: ихэнх үед хэвийн, гэхдээ хааяа маш их өсөлттэй “spike” гардаг.
    Энэ бол heavy tail үзэгдэл.



# what is class
In machine learning, a class is simply a category or label that a data point can belong to in a classification problem.
Think of it as the “type” or “group” you want your model to predict.

🔹 Key Points About Classes
	Discrete categories
		Classes are distinct labels, not continuous numbers.
		Example: {“spam”, “not spam”}, {“cat”, “dog”, “rabbit”}, {“disease”, “healthy”}
	Depends on the problem
		The number of classes depends on the specific classification task:
			Binary classification → 2 classes (e.g., Yes/No)
			Multi-class classification → 3 or more classes (e.g., Cat/Dog/Rabbit)
			Multi-label classification → each instance can belong to multiple classes at the same time
	Used for training
		During training, the model learns to map input features to the correct class.
		The classes are often represented as numbers internally, e.g., 0, 1, 2…

| Task               | Input            | Classes                     |
| ------------------ | ---------------- | --------------------------- |
| Email filtering    | Email content    | Spam, Not Spam              |
| Fruit recognition  | Image of a fruit | Apple, Banana, Orange       |
| Sentiment analysis | Text review      | Positive, Neutral, Negative |



We use classification in machine learning because many real-world problems involve making decisions or assigning things into categories (classes) rather than predicting continuous values.

🔑 Reasons why we do classification:
	Nature of the Problem
		Many tasks are inherently categorical:
			Spam ❌ vs. Not Spam ✅
			Fraudulent 💳 vs. Legitimate transaction
			Disease present 🩺 vs. not present
			Sentiment: Positive 🙂, Negative 🙁, Neutral 😐
	Decision-Making
		In real applications, what we care about is the final decision, not just probabilities. Example: An email system has to decide show in inbox or move to spam
	Interpretability
		Classification provides clear labels that are easy for humans to understand and act on.
	Efficiency in Action
		ystems can take automated actions once a class is determined. Example: If a transaction is classified as fraud → block it.
	Generalization of Knowledge
		Classification allows machines to generalize from past labeled examples to unseen ones.

🧠 Difference vs. Regression
	Regression → predicts how much (continuous value).
	Classification → predicts which category (discrete label).

	Example:
		Regression: "What is the temperature tomorrow?" → 27.3°C
		Classification: "Will it rain tomorrow?" → Yes/No





1. Data Preprocessing & Cleaning
    Before training a model, data should be cleaned and prepared. Things to know:
        Missing values → imputation (mean/median/mode) or removal
        Categorical variables → one-hot encoding, label encoding
        Scaling / normalization → important for models like neural networks or SVMs
        Feature engineering → creating meaningful features from raw data
        Detecting duplicates → remove repeated data that may bias the model

2. Feature Selection
    Choose features that actually help the model learn
    Techniques: correlation analysis, mutual information, recursive feature elimination
    Reduces overfitting, improves interpretability, and reduces training time

3. Model Evaluation Concepts
    Bias vs Variance
        High bias → underfitting, poor training and validation performance
        High variance → overfitting, good training but poor validation performance

    Learning curves → plot training vs validation performance over epochs

    Confusion matrix (classification) → gives detailed performance metrics

4. Regularization Techniques
    Help prevent overfitting:
        L1 (Lasso) → encourages sparsity
        L2 (Ridge) → penalizes large weights
        Dropout → in neural networks, randomly drop neurons during training

5. Cross-Validation
    Useful when dataset is small

    K-Fold or LOOCV allows you to maximize data usage for training while still testing generalization

6. Hyperparameter Tuning & Fine-Tuning
    Choosing best learning rate, batch size, number of layers, tree depth, etc.
    Techniques:
        Grid Search
        Random Search
        Bayesian Optimization

    Fine-tuning pre-trained models (transfer learning)

7. Handling Imbalanced Data
    Some classes appear less frequently → model may ignore them
    Solutions:
        Oversampling minority class (SMOTE)
        Undersampling majority class
        Weighted loss functions

8. Overfitting vs Underfitting
| Type         | Training Error | Validation Error | Solution                           |
| ------------ | -------------- | ---------------- | ---------------------------------- |
| Underfitting | High           | High             | More complex model, more features  |
| Overfitting  | Low            | High             | Regularization, more data, dropout |

9. Model Deployment & Monitoring
    Once tested, models are deployed to production
    Monitor for data drift (new data distribution)
    Retrain when performance drops

10. Evaluation Metrics Recap
    Regression: MSE, RMSE, MAE, R²
    Classification: Accuracy, Precision, Recall, F1, ROC-AUC
    Understand which metric fits your business or research problem